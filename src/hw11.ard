\import Algebra.Meta
\import Data.Bool
\import Equiv
\import Equiv.Univalence
\import Function
\import Function.Meta
\import Logic (<->, prop-isProp)
\import Logic.Meta
\import Meta
\import Paths (inv, pmap)
\import Paths.Meta
\import lect02 (==)
\import lect11


-- 1. Докажите, что если A : \Prop, то Trunc A эквивалентен A

\func trunc-prop {A : \Prop} : Trunc A <-> A => (Trunc-elim id, \lam a => trunc a)


-- 2. Докажите следующий закон де Моргана

\func deMorgan (A B C : \Prop) : (\Sigma A (B `Or` C)) <-> ((\Sigma A B) `Or` (\Sigma A C)) => (\lam x => \case x \with {
  | (a, inl b) => inl (a, b)
  | (a, inr c) => inr (a, c)
}, \lam x => \case x \with {
  | inl (a, b) => (a, inl b)
  | inr (a, c) => (a, inr c)
})

\func deMorgan' (A B C : \Prop) : (\Sigma A (B `Or` C)) <-> ((\Sigma A B) `Or` (\Sigma A C)) =>
  (\lam x => Or-rec (\lam a => inl (x.1, a)) (\lam b => inr (x.1, b)) x.2,
   Or-rec (\lam (x : \Sigma A B) => (x.1, inl x.2)) (\lam x => (x.1, inr x.2)))

\func deMorgan-swap (A B C : \Prop) : (\Sigma (B `Or` C) A) -> (\Sigma B A) `Or` (\Sigma C A) =>
  \lam x => Or-rec (\lam a => inl (a, x.2)) (\lam b => inr (b, x.2)) x.1

-- 3. Определите элиминатор для Or через Or-rec, не используя паттерн матчинг на Or

\func Or-elim {A B : \Prop} (C : Or A B -> \Prop)
              (f : \Pi (x : A) -> C (inl x)) (g : \Pi (y : B) -> C (inr y))
              (p : A `Or` B) : C p =>
  \let
    | a-prop : isProp A => prop-isProp
    | b-prop : isProp B => prop-isProp
    | h => Or-rec (\lam x => inl x) (\lam y => inr y) p
    | t : C p => Or-rec (\lam (x, p-eq) =>
        \let h : C (inl x) = C p => {?} \in
        transport id h (f x)
    ) (\lam (y, p-eq) =>
        \let h : C (inr y) = C p => {?} \in
        transport id h (g y)) $
    deMorgan-swap (p = p) A B (p, idp)
    -- (deMorgan _ A B).1 (p, p)
    -- | p'' => {?} -- Or-rec (\lam x => inl x) (\lam y => inr y) p \in {?}
  \in t


-- 4. Докажите, что тип утверждений является множеством

\func prop-isSet : isSet \Prop => \lam _ _ => prop-isProp

-- 5. Докажите, что функции Prop1-to-Prop2 иProp2-to-Prop1 взаимно обратны и, как следствие, что Prop1 = Prop2

-- use univalence, scase
-- HLevel.isProp levelprop

\func Prop2-to-Prop1'-data (p : Prop1) (prop : isProp p) (x : Prop2-to-Prop1' p prop) : p \elim x
  | inc a => a

\func prop121 (p : Prop1) : (Prop2-to-Prop1 $ Prop1-to-Prop2 p) = p => iso {Prop2-to-Prop1' p prop-isProp} {p}
                                                                           (\lam x => Prop2-to-Prop1'-data p prop-isProp x)
                                                                           (\lam x => inc x)
                                                                           (\lam x => \case \elim x \with {
                                                                             | inc a => idp
                                                                           })
                                                                           (\lam _ => idp)

\sfunc Prop2-to-Prop1'-data' (p : Prop2) (x : Prop2-to-Prop1' p.1 p.2) : p.1 \elim x
  | inc a => a

\sfunc prop212 (p : Prop2) : (Prop1-to-Prop2 $ Prop2-to-Prop1 p) = p => unfold Prop2-to-Prop1 $
                                                                        unfold Prop1-to-Prop2 $
                                                                        ext ({?}, {?})
-- ext (iso {Prop2-to-Prop1' p.1 p.2} {p.1}
--          (\lam x => Prop2-to-Prop1'-data' p x)
--          (\lam x => inc x)
--          (\lam x => \case \elim x \with {
--            | inc a => rewrite Prop2-to-Prop1'.dataIsProp idp
--          })
--          (\lam x => {?})
-- , {?})

\func Prop1-eq-Prop2 : Prop1 = Prop2 => iso Prop1-to-Prop2
                                            Prop2-to-Prop1
                                            prop121
                                            prop212

-- Можно сделать только одно из упражнений 6a, 6b на выбор

-- 6a. Тип С называется когенератором, если для любых множеств A и B и любых функций f, g : A -> B верно,
--     что если h o f = h o g для всех h : B -> C, то f = g
--     Докажите, что \Prop является когенератором

\func isCogenerator (C : \Type) => \Pi {A B : \Set} (f g : A -> B) (p : \Pi (h : B -> C) -> h o f = h o g) -> f = g

\func PropIsCogenerator : isCogenerator \Prop =>
  \lam f g p =>
    ext \lam x =>
        \let
          | p' => p (\lam y => y = f x)
          | eq-eq => unfold (o) $ pmap (\lam f => f x) p'
          | eq => unfold id $ transport id eq-eq idp
        \in inv eq

-- 6b. Тип X называется инъективным, если для любой функции f : A -> X и любой инъекции i : A -> B
--     существует функция l : B -> X такая, что l o i = f
--     Докажите, что \Prop инъективен

\func isInj {A B : \Type} (f : A -> B) => \Pi (x y : A) -> f x = f y -> x = y

\func isInjective (X : \Type) =>
  \Pi {A B : \Type} (f : A -> X) (i : A -> B) (p : isInj i) -> \Sigma (l : B -> X) (l o i = f)

\func Prop-isInjective : isInjective \Prop => \lam {A} {B} f i p => \let j : B -> \Prop => \lam b => ∃ (a : A) (\Sigma (i a = b) (f a))
                                                                    -- ∃ (a : A) (\Sigma (i a = b) (f a))
                                                                    \in (j, ext \lam x => iso {?} {?} {?} {?})


-- Можно сделать только одно из упражнений 7a, 7b на выбор

-- 7a. Докажите, что (Bool = Bool) = Bool

-- Equiv.equals, on all values, Equiv.isInj

-- coe (\lam i => id (p @ i)) true right
-- transport id p true
\func BoolAut : (Bool = Bool) = Bool =>
  iso
    (\lam p => transport id p true)
    (\lam b => iso {Bool} {Bool} (`== b) (`== b) (\lam x => cases (x, b) idp) (\lam x => cases (x, b) idp))
    (\lam p =>
      cases (transport id p true arg addPath) \with {
        | false, pt => {?}
        | true, pt => {?}
      })
    -- pmap (\lam h => transport id h true)
    (\lam b => \case \elim b \with {
      | false => idp
      | true => idp
    } )

-- \func BoolAut' : (Bool = Bool) = Bool =>
--   iso {Bool = Bool} {Bool}
--       (\lam p => sec {=-to-QEquiv p} false)
--       (\lam b => QEquiv-to-= \new QEquiv (`== b) (`== b) (\lam x => cases (x, b) idp) (\lam x => cases (x, b) idp))
--       (\lam p => {?})
--       (\lam b => \case \elim b \with {
--         | false => {?}
--         | true => {?}
--       } )

-- 7b. Докажите, что (n+m)-элементное множество равно размеченному объединению n- и m-элементных множеств
