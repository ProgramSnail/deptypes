\import Algebra.Meta
\import Arith.Int
\import Arith.Nat
\import Data.Bool
\import Function (o)
\import Function.Meta
\import HLevel
\import Logic
\import Logic.Meta
\import Meta
\import Paths
\import Paths.Meta
\import hw07 (contrProp)
\import lect10 (mod3)
\import lect12 \hiding (Int', pos, neg)

-- 1. Определите функцию negPred : Int -> Int такую, что negPred x = x, если x > 0, и negPred x = x - 1, если x <= 0

\func negPred (x : Int) : Int \elim x
  | zero => -1
  | pos n => pos n
  | neg n => neg $ suc n

-- 2. Определите функции сложения и умножения для Int

\func negative' (x : Int) : Int \elim x
  | pos n => neg n
  | neg n => pos n

\func \infixl 6 + (x y : Int) : Int \elim x
  | zero => y
  | pos (suc n) => isuc (pos n + y)
  | neg (suc n) => ipred (neg n + y)

\func \infixl 6 - (x y : Int) : Int => x + negative' y

-- \func \infixl 7 * (x y : Int) : Int \elim x
--   | zero => 0
--   | pos (suc n) => pos n * y + y
--   | neg (suc n) => neg n * y - y

\func \infixl 7 * (x y : Int) : Int \elim x, y
  | pos n, pos m => n * m
  | neg n, neg m => n * m
  | pos n, neg m => negative' $ n * m
  | neg n, pos m => negative' $ n * m

-- 3. Определите тип данных BinNat для бинарных натуральных чисел
--    У него должно быть три конструктора: для 0, для чисел вида 2*n и чисел вида 2*n+1
--    Такой тип данных содержит несколько различных представлений для нуля
--    Используйте типы данных с условиями, чтобы вычислительно отождествить различные нули

\data BinNat
  | B0
  | Bx2 BinNat
  \with {
    | B0 => B0
  }
  | Bx2_1 BinNat

-- 4. Докажите, что функция pred сюръективна

\func pred (n : Nat) : Nat
  | 0 => 0
  | suc n => n

\func pred-is-sur : isSurj pred => unfold isSurj \lam b => inP (suc b, idp)

-- 5. Докажите, что функция suc не сюръективна

\func suc-is-not-sur (p : isSurj suc) : Empty => \case p zero \with {
  | inP (a, a-surj) => \case a-surj
}

-- 6. Пусть f : A -> B и g : B -> C ─ некоторые функции
--    Докажите, что если f и g сюръективны, то g o f также сюръективна
--    Докажите, что если g o f сюръективна, то g также сюръективна

\func o-sur {A B C : \Type} (f : A -> B) (g : B -> C) (p : isSurj f) (q : isSurj g) : isSurj (g o f) => \lam c => \case q c \with {
  | inP (b, b-surj) => \case p b \with {
    | inP (a, a-surj) => inP (a, rewriteI b-surj $ pmap g a-surj)
  }
}

\func o-sur' {A B C : \Type} (f : A -> B) (g : B -> C) (p : isSurj (g o f)) : isSurj g => \lam b => \case p b \with {
  | inP (a, a-surj) => inP (f a, a-surj)
}

-- 7. Определите множество конечных подмножеств множества A,
--    то есть списков элементов A с точностью до перестановок и повторений элементов

\truncated \data Set (A : \Set) : \Set
  | set-singleton A
  | set-add A (Set A)
  | set-eq-repeat (a : A) (s : Set A) (i : I) \elim i {
    | left => set-add a (set-add a s)
    | right => set-add a s
  }
  | set-eq-permute (a b : A) (s : Set A) (i : I) \elim i {
    | left => set-add a (set-add b s)
    | right => set-add b (set-add a s)
  }

-- 8. Докажите теорему Кантора

-- Теорема Кантора говорит, что для любого множества A мощность множества его подмножеств строго больше, чем мощность A

-- Множество подмножеств можно определить следующим образом:

\func Subs (A : \Set) => A -> \Prop

-- Формально утверждение теоремы Кантора состоит из двух частей:
-- "существует инъекция из A в Subs A" и "не существует сюръекции из A в Subs A"
-- Здесь поможет contrProp из hw07

\func cantor1 (A : \Set) : \Sigma (f : A -> Subs A) (isInj f)
  => (=, =-isInj)

\func cantor2 (A : \Set) (f : A -> Subs A) (p : isSurj f) : Empty
  => \let
      | s-t => p (\lam x => Not $ f x x)
     \in \case s-t \with {
      | inP (s, s-surj) =>
        contrProp
          {f s s}
          (\lam is-fss => \let not-fss => rewrite s-surj is-fss \in not-fss)
          (\lam not-fss => \let is-fss => rewrite s-surj not-fss \in \case is-fss not-fss)
     }

-- Optional
-- 9. Постройте функции Nat -> BinNat и BinNat -> Nat и докажите, что они взаимно обратны

\func bsuc (b : BinNat) : BinNat \elim b
  | B0 => Bx2_1 B0
  | Bx2 b => Bx2_1 b
  | Bx2_1 b => Bx2 $ bsuc b 

\func NatToBinNat (n : Nat) : BinNat \elim n
  | zero => B0
  | suc n => bsuc $ NatToBinNat n

\func BinNatToNat (b : BinNat) : Nat \elim b
  | B0 => 0
  | Bx2 b => BinNatToNat b Nat.* 2
  | Bx2_1 b => suc $ BinNatToNat b Nat.* 2


\func nbn'' (b : BinNat) : suc (BinNatToNat b) = BinNatToNat (bsuc b) \elim b
  | B0 => idp
  | Bx2 b => equation
  | Bx2_1 b => rewriteI (nbn'' b) equation

\func nbn' (n : Nat) : suc (BinNatToNat (NatToBinNat n)) = BinNatToNat (NatToBinNat (suc n))
  =>  rewrite (nbn'' (NatToBinNat n)) idp

\func nbn (n : Nat) : BinNatToNat (NatToBinNat n) = n \elim n
  | zero => idp
  | suc n => \let
    | p => pmap suc $ nbn n
    | q => nbn' n
  \in rewriteI q p

\func nat-zero-sum-left {n m : Nat} (p : 0 = n Nat.+ m) : 0 = n \elim n, m, p
  | 0, 0, p => idp
  | suc n, 0, ()

\func nat-zero-sum-right {n m : Nat} (p : 0 = n Nat.+ m) : 0 = m \elim n, m, p
  | 0, 0, p => idp
  | suc n, 0, ()

\lemma nat-x2-eq {n m : Nat} (p : n Nat.* 2 = m Nat.* 2) : n = m
  => NatSemiring.cancel_*-right {n} {m} {2} (\lam p => \case p) p

\lemma nat-x2_1-eq {n m : Nat} (p : n Nat.* 2 Nat.+ 1 = m Nat.* 2 Nat.+ 1) : n = m
  => nat-x2-eq $ NatSemiring.cancel-right 1 p

\lemma not-x2-eq-x2_1 {n m : Nat} (p : n Nat.* 2 = m Nat.* 2 Nat.+ 1) : Empty \elim n, m, p
  | 0, 0, ()
  | suc n, suc m, p => \let p' => pmap pred $ pmap pred $ p \in not-x2-eq-x2_1 p'

\func b-is-zero {b : BinNat} (p : 0 = BinNatToNat b) : b = B0 \elim b, p
  | B0, p => idp
  | Bx2 b, p => pmap Bx2 $ b-is-zero (nat-zero-sum-left p)

\func bnb' (a b : BinNat) (p : BinNatToNat a = BinNatToNat b) : a = b \elim a, b, p
  | B0, B0, _ => idp
  | B0, Bx2 b, p => \let
    | p' => nat-zero-sum-left p
    | q => b-is-zero p'
  \in inv $ pmap Bx2 q
  | Bx2 a, B0, p => \let
    | p' => nat-zero-sum-left $ inv p
    | q => b-is-zero p'
  \in pmap Bx2 q
  | Bx2 a, Bx2 b, p => pmap Bx2 $ bnb' a b $ nat-x2-eq p
  | Bx2_1 a, Bx2_1 b, p => pmap Bx2_1 $ bnb' a b $ nat-x2_1-eq p
  | Bx2_1 a, Bx2 b, p => \case not-x2-eq-x2_1 (inv p)
  | Bx2 a, Bx2_1 b, p => \case not-x2-eq-x2_1 p

\func bnb (b : BinNat) : NatToBinNat (BinNatToNat b) = b =>
  \let
    | n => BinNatToNat b
    | p : n = BinNatToNat b => idp
    | q => rewrite p $ nbn n
  \in bnb' (NatToBinNat (BinNatToNat b)) b q

