\import Data.Bool
\import Function (o)
\import Function.Meta
\import HLevel
\import Logic
\import Meta
\import Paths
\import Paths.Meta
\import hw07 (contrProp)
\import lect10 (mod3)
\import lect12 \hiding (Int', pos, neg)

-- 1. Определите функцию negPred : Int -> Int такую, что negPred x = x, если x > 0, и negPred x = x - 1, если x <= 0

\func negPred (x : Int) : Int \elim x
  | zero => -1
  | pos n => pos n
  | neg n => neg $ suc n

-- 2. Определите функции сложения и умножения для Int

\func incr (x : Int) : Int \elim x
  | zero => 1
  | pos n => pos $ suc n
  | neg (suc n) => neg n

\func decr (x : Int) : Int \elim x
  | zero => -1
  | pos (suc n) => pos n
  | neg n => neg $ suc n

\func negative' (x : Int) : Int \elim x
  | pos n => neg n
  | neg n => pos n

\func \infixl 6 + (x y : Int) : Int \elim x
  | zero => y
  | pos (suc n) => incr (pos n + y)
  | neg (suc n) => decr (neg n + y)

\func \infixl 6 - (x y : Int) : Int => x + negative' y

\func \infixl 7 * (x y : Int) : Int \elim x
  | zero => 0
  | pos (suc n) => pos n * y + y
  | neg (suc n) => neg n * y - y

-- 3. Определите тип данных BinNat для бинарных натуральных чисел
--    У него должно быть три конструктора: для 0, для чисел вида 2*n и чисел вида 2*n+1
--    Такой тип данных содержит несколько различных представлений для нуля
--    Используйте типы данных с условиями, чтобы вычислительно отождествить различные нули

\data BinNat
  | B0
  | Bx2 BinNat
--   \with {
--     | B0 => B0
--   }
  | Bx2_1 BinNat

-- 4. Докажите, что функция pred сюръективна

\func pred (n : Nat) : Nat
  | 0 => 0
  | suc n => n

\func pred-is-sur : isSurj pred => unfold isSurj \lam b => inP (suc b, idp)

-- 5. Докажите, что функция suc не сюръективна

\func suc-is-not-sur (p : isSurj suc) : Empty => \case p zero \with {
  | inP (a, a-surj) => \case a-surj
}

-- 6. Пусть f : A -> B и g : B -> C ─ некоторые функции
--    Докажите, что если f и g сюръективны, то g o f также сюръективна
--    Докажите, что если g o f сюръективна, то g также сюръективна

\func o-sur {A B C : \Type} (f : A -> B) (g : B -> C) (p : isSurj f) (q : isSurj g) : isSurj (g o f) => \lam c => \case q c \with {
  | inP (b, b-surj) => \case p b \with {
    | inP (a, a-surj) => inP (a, rewriteI b-surj $ pmap g a-surj)
  }
}

\func o-sur' {A B C : \Type} (f : A -> B) (g : B -> C) (p : isSurj (g o f)) : isSurj g => \lam b => \case p b \with {
  | inP (a, a-surj) => inP (f a, a-surj)
}

-- 7. Определите множество конечных подмножеств множества A,
--    то есть списков элементов A с точностью до перестановок и повторений элементов

\truncated \data Set (A : \Set) : \Set
  | set-singleton A
  | set-add A (Set A)
  | set-eq-repeat (a : A) (s : Set A) (i : I) \elim i {
    | left => set-add a (set-add a s)
    | right => set-add a s
  }
  | set-eq-permute (a b : A) (s : Set A) (i : I) \elim i {
    | left => set-add a (set-add b s)
    | right => set-add b (set-add a s)
  }

-- 8. Докажите теорему Кантора

-- Теорема Кантора говорит, что для любого множества A мощность множества его подмножеств строго больше, чем мощность A

-- Множество подмножеств можно определить следующим образом:

\func Subs (A : \Set) => A -> \Prop

-- Формально утверждение теоремы Кантора состоит из двух частей:
-- "существует инъекция из A в Subs A" и "не существует сюръекции из A в Subs A"
-- Здесь поможет contrProp из hw07

\func cantor1 (A : \Set) : \Sigma (f : A -> Subs A) (isInj f)
  => (=, =-isInj)

\func cantor2 (A : \Set) (f : A -> Subs A) (p : isSurj f) : Empty
  => \let
      | s-t => p (\lam x => Not $ f x x)
     \in \case s-t \with {
      | inP (s, s-surj) =>
        contrProp
          {f s s}
          (\lam is-fss => \let not-fss => rewrite s-surj is-fss \in not-fss)
          (\lam not-fss => \let is-fss => rewrite s-surj not-fss \in \case is-fss not-fss)
     }

-- Optional
-- 9. Постройте функции Nat -> BinNat и BinNat -> Nat и докажите, что они взаимно обратны

\func divMod2 (_ : Nat) : \Sigma Bool Nat
  | 0 => (false, 0)
  | 1 => (true, 0)
  | suc (suc n) => \let (m, d) => divMod2 n \in
                   (m, suc d)

\func div2 (_ : Nat) : Nat
  | 0 => 0
  | 1 => 0
  | suc (suc n) => suc (div2 n)

\func mod2 (_ : Nat) : Bool
  | 0 => false
  | 1 => true
  | suc (suc n) => mod2 n

\func NatToBinNat'' (n : Nat) : BinNat \elim n
  | 0 => B0
  | suc n => cases (Nat.divMod 2 n arg addPath, Nat.divModProp 2 n arg addPath) \with {
    | (0, m), _, _, _ => Bx2 {?} -- (NatToBinNat'' m)
    | (1, m), _, _, _ => Bx2_1 {?} -- (NatToBinNat'' m)
    | (suc (suc n1),n2), p, x, p1 => {?} -- \case unfold (Nat.mod) $ unfold (Nat.div) $ rewrite p x
  }

\func NatToBinNat' (fuel n : Nat) : BinNat \elim fuel, n
  | _, 0 => B0
  | suc fuel, suc n => \case divMod2 n \with {
    | (false, m) => Bx2 (NatToBinNat' fuel m)
    | (true, m) => Bx2_1 (NatToBinNat' fuel m)
  }
  | 0, suc n => B0 -- should be impossible

\func NatToBinNat (n : Nat) : BinNat => NatToBinNat' n n

\func mult2 (n : Nat) : Nat \elim  n
  | 0 => 0
  | 1 => 2
  | suc n => suc (suc (mult2 n))

\func BinNatToNat (b : BinNat) : Nat \elim b
  | B0 => 0
  | Bx2 b => mult2 (BinNatToNat b)
  | Bx2_1 b => suc $ mult2 (BinNatToNat b)

\func nbn (n : Nat) : BinNatToNat (NatToBinNat n) = n \elim n
  | 0 => idp
  | suc n => cases (divMod2 n arg addPath) \with {
    | (false, m), p => \let
        | p' => {?} -- pmap mult2 $ nbn m
    \in unfold NatToBinNat $ rewrite p {?}
    | (true, m), p => \let
      | p' => {?} -- pmap suc $ pmap mult2 $ nbn m
      \in unfold NatToBinNat $ rewrite p {?}
  }

\func bnb (b : BinNat) : NatToBinNat (BinNatToNat b) = b => {?}
