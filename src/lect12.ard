\import Data.Bool
\import Data.Maybe
\import Equiv
\import Function
\import Function.Meta
\import HLevel
\import Logic
\import Logic.Meta
\import Paths
\import Paths.Meta
\import lect11 (not-not)


-- 0. Теория множеств

-- Типы, являющиеся множествами, ведут себя как множества в теории множеств
-- Это означает, что многие теоремы из неё можно доказать и в теории типов
-- Например, мы можем доказать теорему Кантора, которая говорит, что мощность множества X строго меньше,
-- чем мощность множества его подмножеств, то есть X -> \Prop

-- Определим кардинальность множества:
\truncated \data Card : \Set
  | card \Set

-- Функция card : \Set -> Card, Card : \Set отображает произвольное множество в его кардинальность
-- Благодаря обрезанию (set truncation) мы отождествляем все множества, между которыми существует биекция,
-- ведь в нашей теории любая биекция на множествах задаёт равенство между ними
-- Таким образом для множеств A, B с одинаковой кардинальностью верно card A = card B

\func boolMaybeUnit : card (Maybe (\Sigma)) = card Bool => pmap card $ ext $ \new QEquiv {
  | f => \case __ \with { | nothing => false | just () => true }
  | ret => \case __ \with { | false => nothing | true => just () }
  | ret_f => \case \elim __ \with { | nothing => idp | just () => idp }
  | f_sec => \case \elim __ \with { | false => idp | true => idp }
}

-- Отношение "кардинальность меньше или равна":
\func leq (_ _ : Card) : \Prop
  | card A, card B => ∃ (f : A -> B) (isInj f)

-- Тот факт, что мощность не больше, означает, что существует инъекция из X в X -> \Prop:
-- \lam x => { x } -- возвращаем множество из одного элемента

-- В качестве такой инъекции мы можем просто взять предикат равенства:
-- (=) : X -> (X -> \Prop)

\func =-isInj {X : \Set} : isInj {X} {X -> \Prop} (=)
  => \lam _ y p => transportInv id (pmap (__ y) p) idp

-- Тот факт, что мощность строго меньше, означает, что не существует сюръекции вида
-- f : X -> (X -> \Prop)
-- Это легко доказать так же, как и в классическом случае

-- Некоторые факты невозможно доказать в теории типов,
-- так как мы не предполагаем закон исключенного третьего или аксиому выбора

-- Например, теорема Кантора-Бернштейна, которая говорит, что если одно множество вкладывается в другое и наоборот,
-- то между ними есть биекция, не доказуема без исключенного третьего

-- При необходимости мы можем добавить эти классические принципы
-- Тогда теория станет еще больше похожа на классическую теорию множеств


-- 1. Сюръективные функции

\func isInj {A B : \Set} (f : A -> B) => \Pi (x y : A) -> f x = f y -> x = y

-- Сюръективные функции определяются очевидным образом
-- Обратите внимание, что мы используем обрезание, так как хотим, чтобы этот тип был утверждением
\func isSurj {A B : \Type} (f : A -> B) : \Prop => \Pi (b : B) -> ∃ (a : A) (f a = b)

-- Этот тип соответствует типу всех функций, возвращающих прообраз:
-- \Pi (b : B) -> \Sigma (a : A) (f a = b)

-- А этот тип соответствует наличию хотя бы одной такой функции, что в общем случае более сильное утверждение, чем isSurj
-- TruncP (\Pi (b : B) -> \Sigma (a : A) (f a = b))

\func notIsSurj {A B : \Type} (f : A -> B) (p : isSurj f) : TruncP (\Pi (b : B) -> \Sigma (a : A) (f a = b))
  => inP $ \lam b => {?} -- ???


-- 2. Биекция = инъекция + сюръекция

\func isBij {A B : \Set} (f : A -> B) : \Set
  => \Sigma (g : B -> A) (\Pi (a : A) -> g (f a) = a) (\Pi (b : B) -> f (g b) = b)

-- Несмотря на то, что isBij задан без обрезания, требуемых равенств хватает, чтобы доказать, что это утверждение:
\func isBij-isProp {A B : \Set} (f : A -> B) : isProp (isBij f)
  => \lam p q => ext $ ext \lam b => inv (pmap p.1 (q.3 b)) *> p.2 (q.1 b)

\func isBij->isInj {A B : \Set} (f : A -> B) (p : isBij f) : isInj f \elim p
  | (g, p, _) => \lam x y p' => inv (p x) *> pmap g p' *> p y

\func isBij->isSur {A B : \Set} (f : A -> B) (p : isBij f) : isSurj f \elim p
  | (g, _, q) => \lam b => inP (g b, q b)

\func isInj+isSur->isBij {A B : \Set} (f : A -> B) (inj : isInj f) (surj : isSurj f) : isBij f
  => \have g (b : B) : \Sigma (a : A) (f a = b) => TruncP.remove (\lam x y => ext $ inj x.1 y.1 $ x.2 *> inv y.2) (surj b)
     \in (\lam b => (g b).1, \lam a => inj _ a (g (f a)).2, \lam b => (g b).2)


-- 3. Определение Int

-- Конструкторы в обычных типах данных не пересекаются
-- Другими словами, мы всегда можем доказать, что con1 не равен con2

-- Иногда бывает полезно определять типы данных, в которых это будет не верно
-- Например, удобно определять целые числа как либо положительное натуральное число, либо отрицательное
-- При этом, эти два конструктора будут пересекаться, так как положительный ноль совпадает с отрицательным

-- Чтобы определить такой тип данных, нужно в одном или нескольких конструкторах добавить условия,
-- которые говорят, как он будет вычисляться:

\data Int'
  | pos Nat
  | neg Nat \with {
    | 0 => pos 0
  }

-- Синтаксис такой же, как и для определения функций при помощи паттерн-матчинга
-- Единственное отличие заключается в том, что не обязательно все случаи должны быть покрыты
-- Например, мы можем определить как neg вычисляется только на zero, но не на suc
-- Тогда neg 0 будет вычисляться в pos 0, но neg (suc n) будет уже в нормальной форме как обычный конструктор

-- Когда мы определяем функцию над таким типом данных при помощи паттерн-матчинга, система проверяет,
-- что её значение на эквивалентных конструкторах совпадают

-- Например, следующее определение не пройдет, так как intEx (pos 0) равно 3, а intEx (neg 0) равно 7:
{-
\func intEx (z : Int') : Nat
  | pos n => 3
  | neg n => 7
-}

-- В таком определении очень удобно работать:

\func negative (_ : Int') : Int'
  | pos n => neg n
  | neg n => pos n

\func abs (_ : Int') : Nat
  | pos n => n
  | neg n => n

-- Паттерны, которые вычисляются, можно пропускать в паттерн матчинге
-- Например, в следующей функции мы не определили ее значение на neg 0, но система принимает это определение
\func intEx' (_ : Int') : Nat
  | pos n => 3
  | neg (suc n) => 7

-- intEx' (neg 0) => intEx' (pos 0) => 3


-- 4. Фактор-множества

-- Фактор-множества -- это полезная конструкция над множествами
-- Если A -- множество с отношением эквивалентности "~" на нем,
-- то мы можем определить новое множество A/~ вместе с функцией in~ : A -> A/~,
-- которая делает равными эквивалентные элементы A:
-- A : \Set
-- ~ : A -> A -> \Prop
-- A/~ : \Set
-- in~ : A -> A/~
-- (a ~ a') -> (in~ a = in~ a')
-- (a ~ a') -> I -> A/~

-- Чтобы определить функцию над A/~, достаточно задать её на произвольном элементе a : A так,
-- чтобы эквивалентным элементам соответствовали равные результаты

-- Мы можем использовать примерно следующий синтаксис, но в нем нет доказательства этого условия:
-- \func f (x : A/~) : B
--   | in~ a => b(a)
-- Точный синтаксис приведен ниже

-- Пример использования фактор-множеств -- это рациональные числа,
-- которые определяются как пары целых чисел с точностью до эквивалентности:
-- Rat = (\Sigma Int (x : Int) (Not (x = 0))) / ~,
-- где (n, m, p) ~ (n', m', p') тогда и только тогда, когда n * m' = n' * m

-- Фактор-множества можно определить при помощи типов данных с условиями
-- Мы просто добавляем конструктор с параметром типа I и двумя условиями на него
\truncated \data Quotient (A : \Type) (R : A -> A -> \Type) : \Set
  | in~ A
  --  | equals~ {a a' : A} (R a a') : in~ a = in~ a' -- синтаксический сахар
  | equals~ {x y : A} (R x y) (i : I) \elim i {
    | left => in~ x
    | right => in~ y
  }

-- equals~ r : I -> Quotient A R
-- path (equals~ r) : equals~ r left = equals~ r right
-- Мы использовали \truncated, чтобы отождествить "equals~ _" с idp

-- Тогда path (equals~ {x} {y} r) будет задавать равенство между двумя элементами, указанными в этих условиях
-- В данном случае мы получаем необходимое равенство между эквивалентными элементами
\func quotientEq {A : \Type} {R : A -> A -> \Type} {x y : A} (r : R x y) : in~ x = {Quotient A R} in~ y
  => path $ equals~ r

-- Чтобы определить функцию над Quotient A R, необходимо задать её на элементе вида in~ a и на конструкторе equals~,
-- что соответствует доказательству того, что эквивалентным элементам соответствуют равные значения:
\func quotientEx {A : \Type} {R : A -> A -> \Type} {B : \Set}
                 (f : A -> B) (p : \Pi {x y : A} -> R x y -> f x = f y)
                 (x : Quotient A R) : B \elim x
  | in~ a => f a
  | equals~ r => p r

\func inR-isSurj {A : \Type} {R : A -> A -> \Type} : isSurj (in~ {A} {R})
  => \lam (in~ a) => inP (a, idp)

-- Фактор-множество всегда дополняет отношение R до отношения эквивалентности
\truncated \data RSTClosure {A : \Type} (R : A -> A -> \Type) (x y : A) : \Prop
  | RST-refl (x = y)
  | RST-sym (RSTClosure R y x)
  | RST-trans {z : A} (RSTClosure R x z) (RSTClosure R z y)
  | RST-inc (R x y)

\func eff {A : \Type} (R : A -> A -> \Type) {x y : A} (p : in~ x = {Quotient A R} in~ y) : RSTClosure R x y
  => eff' p

-- Чтобы достать доказательство из равенства нам потребуется усилить индукционную гипотезу:
\func RST-code {A : \Type} {R : A -> A -> \Type} (x : A) (y : Quotient A R) : \Prop \elim y
  | in~ y => RSTClosure R x y
  | equals~ {z1} {z2} r => ext (\lam r1 => RST-trans r1 (RST-inc r), \lam r1 => RST-trans r1 (RST-sym (RST-inc r)))

-- Здесь мы по сути пользуемся аксиомой J:
\func eff' {A : \Type} {R : A -> A -> \Type} {x : A} {y : Quotient A R} (p : in~ x = y) : RST-code x y \elim p
  | idp => RST-refl idp

-- Вложить доказательство в равенство очень легко:
\func eff-inv {A : \Type} (R : A -> A -> \Type) {x y : A} (p : RSTClosure R x y) : in~ x = {Quotient A R} in~ y \elim p
  | RST-refl idp => idp
  | RST-sym p => inv (eff-inv R p)
  | RST-trans p1 p2 => eff-inv R p1 *> eff-inv R p2
  | RST-inc r => path $ equals~ r


-- 5. S1

-- Сфера S1 -- это окружность. Её можно определить как точку base с одним нетривиальным путём loop:
\data S1
  | base
  | loop I \with {
    | left => base
    | right => base
  }

\func ploop : base = base => path loop


-- Покажем, что ploop -- нетривиальный путь
-- Для этого покажем, что в S1 не меньше путей, чем эквивалентностей Bool ~ Bool, отправив ploop в not-not (Bool-code):
\func S1-code (_ : S1) : \Set
  | base => Bool
  | loop i => iso not not not-not not-not i

\func equality=>func {A B : \Type} (p : A = B) : A -> B => transport id p

\func ploop/=idp (p : ploop = idp) : Empty
  => \case pmap (\lam q => transport id (pmap S1-code q) true) p

-- Аналогичным образом можно показать, что на самом деле в S1 в точности Int путей,
-- см. Loop_S1 в стандартной библиотеке
